""" ADEF post-simulation steps required to successfully save experimental results """

from __future__ import annotations

import glob
import os
import sys
import pandas as pd
import json

PATHS = ["../mev/adm", "../tools", "../mev/result/ppt", "../mev/result/latex"]
for path in PATHS:
    path = os.path.abspath(os.path.join(os.path.dirname(__file__), path))
    if path not in sys.path:
        sys.path.insert(1, path)

from tools.log import Log
from mev.result.ppt.ppt_exp import ExperimentPresentation
from mev.result.latex.tex_gen import LaTeXGenerator


class PostProcessor:
    """
    Class implementing post-processing activities to generalize and
    aggregate all experimental results on higher level of meta experiment.
    """

    def __init__(self,
                 cfg: dict,
                 attack_names: list,
                 algo: dict,
                 attack_files: dict,
                 logger: Log) -> None:
        """
        Args:
            cfg     - Experiment JSON configuration
            attack_names - name of the attacks generated by experiment
            algo: - anomaly detection algorithms configuration
            attack_files - attack files used in the experimentation
            logger  - logger object
        Returns:
            <None>
        """
        self.cfg = cfg
        self.log = logger

        self.exp_prs = ExperimentPresentation(self.cfg, self.log)
        self.exp_tex = LaTeXGenerator(self.cfg, self.log)

        # ROC computation mapping
        self.mapping = {"roc": 0, "eer": 2, "d1": 3, "d2": 4}

        # LaTeX conversion
        self.d_names = list(self.mapping.keys())

        # Data set ordering list used in documents generation
        self.detector_names = {
            x: y for (x, y) in self.cfg["model"]["ad"].items() if y["enabled"]
        }.keys()

        self.attack_names = attack_names
        self.algo = algo
        self.attack_files = attack_files
        self.data_set_types = ["auc", "acc", "f1", "d1", "d2", "eer"]

    def extract_data(self, data: pd.DataFrame, timing: dict) -> dict:
        """
        Extract data from given data set
        Args:
            data: key/value pairs of file names and pd.Dataframes storing
                  data inside corresponding file.
            timing: key/value pair data set storing simulation step and execution time.
        Returns:
            <dict> - dictionary containing data structure ready for presentation
        """

        ds = {
            "Training time": timing["STEP 3"],
            "Evaluation time": timing["STEP 4"],
            "Cycle detector time": timing["STEP 5"],
        }

        sec_multiplayer = 60 / self.cfg["process"]["samples"]

        # Iterate through columns and rows to create a table
        for row in data.iterrows():
            algo_name = row[0][0]
            attack_name = row[0][1]
            columns = row[1].index.tolist()

            row_set = {
                key: val
                for (key, val) in zip(columns, [None for i in range(0, len(columns))])
            }

            if algo_name not in ds.keys():
                ds[algo_name] = {}

            if attack_name not in ds[algo_name].keys():
                ds[algo_name][attack_name] = row_set.copy()

            for col in columns:
                if "_" in col:
                    if col in ds[algo_name][attack_name].keys():
                        del ds[algo_name][attack_name][col]
                    if "avg" in col:
                        continue
                    field = col.split("_")[0]
                    if field not in ds[algo_name][attack_name].keys():
                        if col.startswith("d1") or col.startswith("d2"):
                            ds[algo_name][attack_name][field] = [
                                row[1][col] * sec_multiplayer
                            ]
                        else:
                            ds[algo_name][attack_name][field] = [row[1][col]]
                    else:
                        if col.startswith("d1") or col.startswith("d2"):
                            ds[algo_name][attack_name][field].append(
                                row[1][col] * sec_multiplayer
                            )
                        else:
                            ds[algo_name][attack_name][field].append(row[1][col])
                else:
                    ds[algo_name][attack_name][col] = row[1][col]
                    if col.startswith("d1") or col.startswith("d2"):
                        ds[algo_name][attack_name][col] *= sec_multiplayer

        return ds

    def to_latex(self, datas: list) -> None:
        """
        Method converts computed results into LATEX table format
        Args:
            datas       - list of inputs to generate AD and CD results
                data        - dictionary of pd.DataFrames with AD experiment results
                captions    - captions for each table
                file_name   - name of the LaTeX file
        Returns:
            <None>
        """
        self.exp_tex.run(datas)

    def to_ppt(self, prob: str, ad_data: dict, cd_data: dict, file_name: str) -> None:
        """
        Args:
            prob: probability of data input balance between attacks and normal traces
            ad_data     - AD data input from experiment
            cd_data     - Cycle Detector data input from experiment
            file_name   - name of the file where presentation will be generated
        Returns:
            <None>
        """
        self.exp_prs.run(prob, ad_data, cd_data, file_name)

    # ---------------------------------------------------------------------

    def run(self, folder: str, timing: dict) -> None:
        """
        Method aggregates all post-processing tasks
        Args:
            folder - folder from where analysis will be performed
            timing - timing information about each step of the experiment
        Returns:
            None
        """
        if not os.path.isdir(folder):
            self.log.error(f"Folder {folder} doesn't exists")
            return

        if not self.cfg["results"]["graphs"]["enabled"]:
            return

        out_folder = folder

        # Takeout top level folder to go to output
        if out_folder.endswith("/"):
            out_folder = out_folder[:-1]

        out_folder = f"{out_folder[:out_folder.rindex('/')]}/"

        # 1. Gather all input files
        for prob_set in self.cfg["attack"]["densities"]:
            probability = f"{int(prob_set * 100):02d}"
            # Find all files with given probability set
            prob_metric_files = glob.glob(f"{folder}a_data_{probability}_metric.csv")
            if prob_metric_files:
                m_data = pd.read_csv(prob_metric_files[0])

                ad_data = m_data[m_data["type"] == "ad"]
                ad_data.set_index(["algo", "attack"], inplace=True)

                cd_data = m_data[m_data["type"] == "cd"]
                cd_data.set_index(["algo", "attack"], inplace=True)

                # Extract data and convert it to results generator format
                ds_ad = self.extract_data(ad_data, timing)
                ds_cd = self.extract_data(cd_data, timing)

                # 3. Generate LaTeX table
                if self.cfg["results"]["latex"]["enabled"]:
                    if not os.path.isdir(
                        f"{out_folder}{self.cfg['results']['latex']['path']}"
                    ):
                        os.makedirs(
                            f"{out_folder}{self.cfg['results']['latex']['path']}"
                        )
                    use_case_name = self.cfg["experiment"]["id"]
                    data = [
                            [
                                ds_ad,
                                f"AD model results for use case {use_case_name}.",
                                f"{out_folder}{self.cfg['results']['latex']['path']}"
                                f"{self.cfg['experiment']['id'].lower()}_ad.tex",
                            ],
                            [
                                ds_cd,
                                f"CD model results for use case {use_case_name}.",
                                f"{out_folder}{self.cfg['results']['latex']['path']}"
                                f"{self.cfg['experiment']['id'].lower()}_cd.tex",
                            ],
                        ]

                    json_file = (f"{out_folder}{self.cfg['results']['latex']['path']}"
                                 f"{self.cfg['experiment']['id'].lower()}_"
                                 f"{'_'.join(self.attack_names)}.json")

                    with open(json_file, "w") as f2w:
                        json.dump(data, f2w)

                    self.to_latex(data)

                # 4. Generate presentation table
                if self.cfg["results"]["ppt"]["enabled"]:
                    if not os.path.isdir(
                        f"{out_folder}{self.cfg['results']['ppt']['path']}"
                    ):
                        os.makedirs(f"{out_folder}{self.cfg['results']['ppt']['path']}")

                    sum_folder = out_folder[:-1]
                    sum_folder = sum_folder[: sum_folder.rindex("/")]
                    # sum_prs_file = f"{sum_folder}/summary/{self.cfg['experiment']['id'].lower()}_summary.pptx"
                    algo_names = "_".join(list(self.detector_names))

                    self.to_ppt(
                        probability,
                        ds_ad,
                        ds_cd,
                        f"{out_folder}{self.cfg['results']['ppt']['path']}"
                        f"{algo_names}_{self.cfg['experiment']['id'].lower()}_{self.cfg['process']['cycles']}.pptx",
                    )

            else:
                self.log.error(
                    "Problem with generating results. Result files are empty!"
                )
                self.log.error(f"Metric files: {prob_metric_files}")
